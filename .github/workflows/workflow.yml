# .github/workflows/sync-project-fields.yml
# 目的:
# - 親プロジェクト -> 子プロジェクト へ一方向に Status / startDate / endDate を同期
# - 次のいずれかを満たすアイテムのみ同期対象にする:
#   1) Issue/PR に特定のラベルが付いている
#   2) 親プロジェクトの single-select フィールド「機能名」が特定の値のいずれかである
#
# 準備:
# - 親/子プロジェクトに同名のフィールドを作成: Status (Single-select), startDate (Date), endDate (Date)
# - 親/子の Status の選択肢名を一致させる
# - Org のシークレットに PAT を保存: ORG_PROJECTS_TOKEN (Projects: Read/Write)

name: Sync Projects (parent -> children) with filters

on:
  workflow_dispatch:
    inputs:
      auto_add:
        description: Add missing items to child projects if not present
        type: boolean
        default: false
  schedule:
    - cron: "*/15 * * * *"

permissions:
  contents: read

env:
  OWNER_LOGIN: iwashitahga                # 組織のログイン名に置き換え
  PARENT_PROJECT_NUMBER: "1"        # 親プロジェクト番号に置き換え
  CHILD_PROJECT_NUMBERS: "2"     # 子プロジェクト番号（カンマ区切り）に置き換え

  # 同期するフィールド名（親・子で同名にしておく）
  FIELD_STATUS: "Status"             # 単一選択フィールド
  FIELD_START: "Start date"           # 日付フィールド
  FIELD_END: "End date"               # 日付フィールド

  # フィルタ設定（いずれかを満たすアイテムのみ同期）
  FILTER_LABELS: "opg"     # ラベル名（カンマ区切り、空なら無効）
  FEATURE_FIELD_NAME: "機能名"       # 親プロジェクトに存在する single-select フィールド名
  FEATURE_VALUES: "五輪"        # 機能名フィールドの許容値（カンマ区切り、空なら無効）
  FILTER_MODE: "OR"                  # OR（どちらか一致）/ AND（両方一致）

  # ログ制御
  LOG_MODE: "filtered"               # off | filtered | matched | all
  LOG_LIMIT: "200"                   # ログ行数上限

  GH_TOKEN: ${{ secrets.ORG_PROJECTS_TOKEN }}
  AUTO_ADD: ${{ github.event.inputs.auto_add }}

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Sync parent -> children (filtered, with logging)
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const OWNER = process.env.OWNER_LOGIN;
            const PARENT_NUM = parseInt(process.env.PARENT_PROJECT_NUMBER, 10);
            const CHILD_NUMS = process.env.CHILD_PROJECT_NUMBERS.split(",").map(s=>parseInt(s.trim(),10));
            const FIELD_STATUS = process.env.FIELD_STATUS;
            const FIELD_START = process.env.FIELD_START;
            const FIELD_END = process.env.FIELD_END;

            const FILTER_LABELS = (process.env.FILTER_LABELS || "").split(",").map(s=>s.trim()).filter(Boolean);
            const FEATURE_FIELD_NAME = process.env.FEATURE_FIELD_NAME || "機能名";
            const FEATURE_VALUES = (process.env.FEATURE_VALUES || "").split(",").map(s=>s.trim()).filter(Boolean);
            const FILTER_MODE = (process.env.FILTER_MODE || "OR").toUpperCase();
            const AUTO_ADD = (process.env.AUTO_ADD || 'false') === 'true';

            const LOG_MODE = (process.env.LOG_MODE || "filtered").toLowerCase(); // off|filtered|matched|all
            const LOG_LIMIT = parseInt(process.env.LOG_LIMIT || "200", 10);
            let logCount = 0;
            let logSuppressed = false;

            const labelSet = new Set(FILTER_LABELS);
            const featureSet = new Set(FEATURE_VALUES);

            function canLog(ok) {
              if (LOG_MODE === 'off') return false;
              if (LOG_MODE === 'all') return true;
              if (LOG_MODE === 'matched') return !!ok;
              if (LOG_MODE === 'filtered') return !ok;
              return false;
            }
            function maybeLog(msg) {
              if (!msg) return;
              if (logSuppressed) return;
              if (logCount < LOG_LIMIT) {
                core.info(msg);
                logCount++;
              } else if (!logSuppressed) {
                core.info(`[filter] (further logs suppressed after ${LOG_LIMIT} lines)`);
                logSuppressed = true;
              }
            }
            function itemKey(parent, contentId) {
              const c = parent.itemByContentId[contentId]?.content;
              if (!c) return contentId;
              if (c.__typename === 'Issue' || c.__typename === 'PullRequest') {
                return `${c.repository.nameWithOwner}#${c.number}`;
              }
              return `${c.__typename}:${contentId}`;
            }

            // repositoryOwner(login: ...) で User/Org どちらでも取得
            async function getProject(ownerLogin, number) {
              const q = `
              query($login:String!,$number:Int!,$after:String) {
                repositoryOwner(login:$login) {
                  __typename
                  ... on User {
                    projectV2(number:$number){
                      id title
                      fields(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                      items(first:100, after:$after){
                        pageInfo{ hasNextPage endCursor }
                        nodes{
                          id
                          content{
                            __typename
                            ... on Issue {
                              id number
                              repository { nameWithOwner }
                              labels(first:100){ nodes{ name } }
                            }
                            ... on PullRequest {
                              id number
                              repository { nameWithOwner }
                              labels(first:100){ nodes{ name } }
                            }
                          }
                          fieldValues(first:50){
                            nodes{
                              __typename
                              ... on ProjectV2ItemFieldSingleSelectValue{
                                field{ __typename ... on ProjectV2FieldCommon { id name } }
                                name
                              }
                              ... on ProjectV2ItemFieldDateValue{
                                field{ __typename ... on ProjectV2FieldCommon { id name } }
                                date
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  ... on Organization {
                    projectV2(number:$number){
                      id title
                      fields(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                      items(first:100, after:$after){
                        pageInfo{ hasNextPage endCursor }
                        nodes{
                          id
                          content{
                            __typename
                            ... on Issue {
                              id number
                              repository { nameWithOwner }
                              labels(first:100){ nodes{ name } }
                            }
                            ... on PullRequest {
                              id number
                              repository { nameWithOwner }
                              labels(first:100){ nodes{ name } }
                            }
                          }
                          fieldValues(first:50){
                            nodes{
                              __typename
                              ... on ProjectV2ItemFieldSingleSelectValue{
                                field{ __typename ... on ProjectV2FieldCommon { id name } }
                                name
                              }
                              ... on ProjectV2ItemFieldDateValue{
                                field{ __typename ... on ProjectV2FieldCommon { id name } }
                                date
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }`;

              let items = [];
              let after = null;
              let project = null;
              let fields = [];

              do {
                const res = await github.graphql(q, { login: ownerLogin, number, after });
                const owner = res.repositoryOwner;
                if (!owner) throw new Error(`RepositoryOwner not found for login=${ownerLogin}`);
                project = owner.projectV2;
                if (!project) throw new Error(`ProjectV2 not found for ${ownerLogin} #${number}`);
                fields = project.fields.nodes;
                items.push(...project.items.nodes);
                after = project.items.pageInfo.hasNextPage ? project.items.pageInfo.endCursor : null;
              } while (after);

              const fieldByName = {};
              for (const f of fields) if (f?.name) fieldByName[f.name] = f;

              const itemByContentId = {};
              const valuesByContentId = {};
              const labelsByContentId = {};

              for (const it of items) {
                if (!it.content) continue;
                const contentId = it.content.id;
                itemByContentId[contentId] = { itemId: it.id, content: it.content };

                const labelNames = (it.content.labels?.nodes || []).map(n => n.name).filter(Boolean);
                labelsByContentId[contentId] = labelNames;

                const v = {};
                for (const fv of it.fieldValues.nodes || []) {
                  if (fv.__typename === 'ProjectV2ItemFieldSingleSelectValue') {
                    const fieldName = fv.field?.name;
                    if (fieldName === FIELD_STATUS) v.statusName = fv.name || null;
                    if (fieldName === FEATURE_FIELD_NAME) v.featureName = fv.name || null; // single-select option name
                  } else if (fv.__typename === 'ProjectV2ItemFieldDateValue') {
                    const fieldName = fv.field?.name;
                    if (fieldName === FIELD_START) v.startDate = fv.date || null;
                    if (fieldName === FIELD_END) v.endDate = fv.date || null;
                  }
                }
                valuesByContentId[contentId] = v;
              }

              return {
                id: project.id,
                title: project.title,
                fieldByName,
                itemByContentId,
                valuesByContentId,
                labelsByContentId
              };
            }

            // フィルタ評価 + 詳細ログ用情報
            function evaluateSync(contentId, parent) {
              const labels = parent.labelsByContentId[contentId] || [];
              const vals = parent.valuesByContentId[contentId] || {};
              const featureName = vals.featureName || null;

              const matchedLabels = labelSet.size ? labels.filter(l => labelSet.has(l)) : [];
              const matchLabel = matchedLabels.length > 0;
              const matchFeature = featureSet.size ? !!(featureName && featureSet.has(featureName)) : false;

              let ok;
              if (labelSet.size === 0 && featureSet.size === 0) {
                ok = true; // フィルタ未設定なら全件同期
              } else if (FILTER_MODE === 'AND') {
                const needLabel = labelSet.size > 0;
                const needFeature = featureSet.size > 0;
                const okLabel = needLabel ? matchLabel : false;
                const okFeature = needFeature ? matchFeature : false;
                ok = okLabel && okFeature;
              } else {
                ok = matchLabel || matchFeature; // OR
              }

              return {
                ok,
                labels,
                matchedLabels,
                featureName,
                matchLabel,
                matchFeature
              };
            }

            // フィルタ評価ログ出力
            function logDecision(contentId, parent, evalRes) {
              const key = itemKey(parent, contentId);
              const parts = [];
              parts.push(`ok=${evalRes.ok}`);
              parts.push(`mode=${FILTER_MODE}`);
              if (labelSet.size > 0) {
                parts.push(`labels=[${(evalRes.labels || []).join(", ")}]`);
                parts.push(`matchedLabels=[${(evalRes.matchedLabels || []).join(", ")}]`);
              }
              if (featureSet.size > 0) {
                parts.push(`feature="${evalRes.featureName ?? "-"}"`);
                parts.push(`featureMatched=${evalRes.matchFeature}`);
              }
              maybeLog(`[filter] ${key} | ${parts.join(" | ")}`);
            }

            core.info(`Owner=${OWNER} | Filter labels=[${FILTER_LABELS.join(", ")}], featureField="${FEATURE_FIELD_NAME}", featureValues=[${FEATURE_VALUES.join(", ")}], mode=${FILTER_MODE}, LOG_MODE=${LOG_MODE}, LOG_LIMIT=${LOG_LIMIT}`);

            // 親プロジェクト取得
            const parent = await getProject(OWNER, PARENT_NUM);
            core.info(`Parent: ${parent.title}`);

            const parentStatusField = parent.fieldByName[FIELD_STATUS];
            const parentStartField = parent.fieldByName[FIELD_START];
            const parentEndField = parent.fieldByName[FIELD_END];
            if (!parentStatusField) core.warning(`Parent field not found: ${FIELD_STATUS}`);
            if (!parentStartField) core.warning(`Parent field not found: ${FIELD_START}`);
            if (!parentEndField) core.warning(`Parent field not found: ${FIELD_END}`);

            // 子へ同期
            for (const childNum of CHILD_NUMS) {
              core.startGroup(`Sync -> Child Project #${childNum}`);
              try {
                const child = await getProject(OWNER, childNum);
                core.info(`Child: ${child.title}`);

                const childStatusField = child.fieldByName[FIELD_STATUS];
                const childStartField = child.fieldByName[FIELD_START];
                const childEndField = child.fieldByName[FIELD_END];

                if (!childStatusField || !childStartField || !childEndField) {
                  core.warning(`Child ${child.title}: Missing fields. Status:${!!childStatusField} startDate:${!!childStartField} endDate:${!!childEndField}`);
                }

                // Status 選択肢マップ（name -> optionId）
                const childStatusOptions = {};
                if (childStatusField?.options) {
                  for (const opt of childStatusField.options) childStatusOptions[opt.name] = opt.id;
                }

                let updated = 0, skipped = 0, added = 0, filteredOut = 0;

                for (const [contentId, parentVals] of Object.entries(parent.valuesByContentId)) {
                  const evalRes = evaluateSync(contentId, parent);
                  if (canLog(evalRes.ok)) {
                    logDecision(contentId, parent, evalRes);
                  }
                  if (!evalRes.ok) { filteredOut++; continue; }

                  // 子に無ければ追加
                  let childItem = child.itemByContentId[contentId];
                  if (!childItem && AUTO_ADD) {
                    const newItemId = await (async () => {
                      const m = `
                      mutation($projectId:ID!,$contentId:ID!){
                        addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){
                          item { id }
                        }
                      }`;
                      try {
                        const res = await github.graphql(m, { projectId: child.id, contentId });
                        return res.addProjectV2ItemById.item.id;
                      } catch (e) {
                        core.warning(`addProjectV2ItemById failed: ${e.message}`);
                        return null;
                      }
                    })();
                    if (newItemId) { childItem = { itemId: newItemId }; added++; }
                  }
                  if (!childItem) { skipped++; continue; }

                  const itemId = childItem.itemId;

                  // Status
                  if (parentVals.statusName && childStatusField) {
                    const targetOptId = childStatusOptions[parentVals.statusName];
                    if (targetOptId) {
                      const m = `
                      mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$value:ProjectV2FieldValue!){
                        updateProjectV2ItemFieldValue(input:{
                          projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                        }){ projectV2Item{ id } }
                      }`;
                      await github.graphql(m, { projectId: child.id, itemId, fieldId: childStatusField.id, value: { singleSelectOptionId: targetOptId } });
                      updated++;
                    } else {
                      core.warning(`Child ${child.title}: Status option "${parentVals.statusName}" not found for ${itemKey(parent, contentId)}`);
                    }
                  }
                  // startDate
                  if (parentVals.startDate && childStartField) {
                    const m = `
                    mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$value:ProjectV2FieldValue!){
                      updateProjectV2ItemFieldValue(input:{
                        projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                      }){ projectV2Item{ id } }
                    }`;
                    await github.graphql(m, { projectId: child.id, itemId, fieldId: childStartField.id, value: { date: parentVals.startDate } });
                    updated++;
                  }
                  // endDate
                  if (parentVals.endDate && childEndField) {
                    const m = `
                    mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$value:ProjectV2FieldValue!){
                      updateProjectV2ItemFieldValue(input:{
                        projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                      }){ projectV2Item{ id } }
                    }`;
                    await github.graphql(m, { projectId: child.id, itemId, fieldId: childEndField.id, value: { date: parentVals.endDate } });
                    updated++;
                  }
                }

                core.info(`Child ${child.title}: updated=${updated} skipped=${skipped} added=${added} filteredOut=${filteredOut}`);
              } finally {
                core.endGroup();
              }
            }

